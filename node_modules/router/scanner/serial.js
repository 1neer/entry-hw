 'use strict';
function Scanner() {
}

Scanner.prototype.startScan = function(extension, config, callback) {
	var serialport = require('serialport');
	var self = this;

	self.scanning = true;
	self.slaveTimers = {};
	self.connectors = {};
	self.clearConnectors();
	self.clearTimers();
	self.timer = setInterval(function() {
		serialport.list(function(error, devices) {
			if(error) {
				if(callback) {
					callback(error);
				}
				return;
			}

			var vendor = config.hardware.vendor;
			var control = config.hardware.control;
			var duration = config.hardware.duration;
			var firmwarecheck = config.hardware.firmwarecheck;
			devices.forEach(function(device) {
				if(!self.scanning) return;
				if(!vendor || (device.manufacturer && device.manufacturer.indexOf(vendor) != -1)) {
					var comName = device.comName || config.hardware.name;
				    var connector = require('../connector/serial').create();
					self.connectors[comName] = connector;

					connector.open(comName, config.hardware, function(error, sp) {
						if(error) {
							if(callback) {
								callback(error);
							}
						} else if(control) {
                            var flashFirmware;
							if(firmwarecheck) {
								flashFirmware = setTimeout(function () {
                                    sp.removeAllListeners('data');
                                    connector.executeFlash = true;
    								self.finalizeScan(comName, connector, callback);
								}, 1000);
							}

                            if(control == 'master') {
								if(extension.checkInitialData && extension.requestInitialData) {
									sp.on('data', function(data) {
										var result = extension.checkInitialData(data, config);
										if(result === undefined) {
											var data = extension.requestInitialData();
											if(data) {
												sp.write(data);
											}
										} else {
											sp.removeAllListeners('data');
                                            clearTimeout(flashFirmware);
											if(result === true) {
												self.finalizeScan(comName, connector, callback);
											} else if(callback) {
												callback(new Error('Invalid hardware'));
											}
										}
									});
								}
							} else {
								if(duration && extension.checkInitialData && extension.requestInitialData) {
									sp.on('data', function(data) {
										var result = extension.checkInitialData(data, config);
										if(result !== undefined) {
											sp.removeAllListeners('data');
                                            clearTimeout(flashFirmware);
											if(result === true) {
												self.finalizeScan(comName, connector, callback);
											} else if(callback) {
												callback(new Error('Invalid hardware'));
											}
										}
									});
									var slaveTimer = self.slaveTimers[comName];
									if(slaveTimer) {
										clearInterval(slaveTimer);
									}
									slaveTimer = setInterval(function() {
										if(!self.scanning) {
											clearInterval(slaveTimer);
											return;
										}
										var data = extension.requestInitialData();
										if(data) {
											sp.write(data);
										}
									}, duration);
									self.slaveTimers[comName] = slaveTimer;
								}
							}
						} else {
							self.finalizeScan(comName, connector, callback);
						}
					});
				}
			});
		});
	}, 1000);
};

Scanner.prototype.stopScan = function() {
	this.scanning = false;
	this.clearTimers();
	this.clearConnectors();
};

Scanner.prototype.clearTimers = function() {
	if(this.timer) {
		clearInterval(this.timer);
		this.timer = undefined;
	}
	var slaveTimers = this.slaveTimers;
	if(slaveTimers) {
		var slaveTimer;
		for(var key in slaveTimers) {
			slaveTimer = slaveTimers[key];
			if(slaveTimer) {
				clearInterval(slaveTimer);
			}
		}
	}
	this.slaveTimers = {};
};

Scanner.prototype.finalizeScan = function(comName, connector, callback) {
	if(this.connectors && comName) {
		this.connectors[comName] = undefined;
	}
	this.stopScan();

	if(callback) {
		callback(null, connector);
	}
};

Scanner.prototype.clearConnectors = function() {
	var connectors = this.connectors;
	if(connectors) {
		var connector;
		for(var key in connectors) {
			connector = connectors[key];
			if(connector) {
				connector.clear();
			}
		}
	}
	this.connectors = {};
};

module.exports = new Scanner();
